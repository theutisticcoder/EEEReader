<!DOCTYPE html>
<html>

<head>
    <title>EEEReader</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
        }

        #message {
            margin-top: 10px;
            padding: 10px;
            border: 1px solid #ccc;
            background-color: #f9f9f9;
            display: none;
        }

        #output {
            white-space: pre-wrap;
            word-wrap: break-word;
            min-height: 100px;
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #eee;
            padding: 10px;
            background-color: #fff;
            margin-top: 20px;
            font-size: 1.1em;
            line-height: 1.6;
        }

        #controls {
            margin-top: 15px;
            display: flex;
            /* Make buttons align nicely */
            flex-wrap: wrap;
            /* Allow buttons to wrap */
        }

        #controls button {
            padding: 8px 15px;
            margin-right: 10px;
            margin-bottom: 5px;
            /* Add some space below buttons */
            cursor: pointer;
        }

        input[type="file"] {
            margin-right: 10px;
        }

        #status {
            margin-top: 10px;
            font-weight: bold;
        }

        #wordsReadDiv {
            margin-top: 10px;
            font-style: italic;
            color: #555;
        }

        #chapterNav {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #ddd;
            background-color: #f0f0f0;
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }

        #chapterNav button {
            display: block;
            width: 100%;
            text-align: left;
            padding: 8px 10px;
            margin-bottom: 5px;
            background-color: #e0e0e0;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            /* Indentation for subchapters */
            box-sizing: border-box;
            /* Include padding in width calculation */
        }

        #chapterNav button:hover {
            background-color: #d0d0d0;
        }

        #chapterNav button.active {
            background-color: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }

        #savedBooksList {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #cce;
            background-color: #eef;
            max-height: 250px;
            overflow-y: auto;
        }

        .saved-book-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            border-bottom: 1px dotted #ddf;
        }

        .saved-book-item:last-child {
            border-bottom: none;
        }

        .saved-book-item span {
            flex-grow: 1;
            padding-right: 10px;
        }

        .saved-book-item button {
            margin-left: 5px;
            padding: 5px 10px;
        }

        /* New style for bolding effect */
        .bold-word {
            font-weight: bold;
        }
    </style>
</head>

<body>
    <h1>EPUB SpEEEd Reader</h1>

    <div id="message"></div>

    <input type="file" id="epubFile" accept=".epub">
    <button onclick="processEpub()">Load & Process New EPUB</button>

    <div id="savedBooksList">
        <h2>Your Saved Books:</h2>
        <div id="savedBooksContainer">
        </div>
        <button onclick="clearAllSavedBooks()" style="margin-top: 10px;">Clear All Saved Books</button>
    </div>

    <div id="controls">

        <label for="wpm">Words Per Minute:</label>
        <input value="1500" type="number" name="wpm" min="200" max="4000" id="wpm">
        <button id="startButton" onclick="startReading()" disabled>Start Reading</button>
        <button id="pauseResumeButton" onclick="togglePauseResume()" disabled>Pause</button>
        <button id="prevButton" onclick="showPrevParagraph()" disabled>&lt; Previous</button>
        <button id="nextButton" onclick="showNextParagraph()" disabled>Next &gt;</button>
        <button id="resetSpotButton" onclick="resetReadingSpot()" disabled>Reset Spot (Current Book)</button>
        <button id="resetTotalWordsButton" onclick="resetTotalWordsRead()">Reset Total Words (All Books)</button>
        <button id="audio" onclick="location.href = 'audio.html'">Listen Instead</button>

    </div>
    <div id="status"></div>
    <div id="wordsReadDiv"></div>

    <div id="chapterNav">
        <h2>Chapters:</h2>
    </div>

    <div id="output"></div>

    <script>
        // --- LocalStorage Keys ---


        const SAVED_BOOKS_KEY = 'epubReaderSavedBooks';
        const TOTAL_WORDS_READ_KEY = 'totalWordsRead';
        document.getElementById('wpm').addEventListener('input', function () {
            localStorage.setItem('wpm', this.value); // Save WPM to localStorage
        });
        // Load saved WPM from localStorage on page load
        const savedWPM = localStorage.getItem('wpm');
        if (savedWPM) {
            document.getElementById('wpm').value = savedWPM;
        } else {
            document.getElementById('wpm').value = 1500; // Default WPM
        }
        // --- Global State Variables for the CURRENTLY ACTIVE Book ---
        let activeBookId = null;
        let allParagraphs = []; // Paragraphs of the currently loaded chapter
        let currentIndex = 0; // Current paragraph index within the loaded chapter
        let currentChapterIndex = 0; // Index of the currently loaded chapter in `chapters` array (flat index)
        let isPlaying = false; // Controls auto-advance for paragraphs (now driven by word bolding)
        let intervalId = null; // This will now be used for word bolding interval
        const boldingSpeed = 30; // 0.03 seconds (30 milliseconds) for word bolding

        let currentWordIndex = 0; // Tracks which word is currently bolded
        let totalWordsRead = 0; // Accumulates across all books and sessions
        let chapters = []; // Flat list of all leaf chapters of the CURRENTLY ACTIVE book, with hierarchy info

        // --- DOM Elements ---
        const outputDiv = document.getElementById('output');
        const messageDiv = document.getElementById('message');
        const statusDiv = document.getElementById('status');
        const wordsReadDiv = document.getElementById('wordsReadDiv');
        const chapterNavDiv = document.getElementById('chapterNav');
        const savedBooksContainer = document.getElementById('savedBooksContainer');

        const startButton = document.getElementById('startButton');
        const pauseResumeButton = document.getElementById('pauseResumeButton');
        const prevButton = document.getElementById('prevButton');
        const nextButton = document.getElementById('nextButton');
        const resetSpotButton = document.getElementById('resetSpotButton');
        const resetTotalWordsButton = document.getElementById('resetTotalWordsButton');

        // --- Utility Functions ---

        /**
         * Generates a unique ID for a book based on file metadata.
         * @param {object} fileInfo - Object containing file properties like name, size, lastModified.
         * @returns {string} A unique identifier for the book.
         */
        function generateBookId(fileInfo) {
            return `${fileInfo.name}-${fileInfo.size}-${fileInfo.lastModified}`;
        }

        /**
         * Counts the number of words in a given text string.
         * @param {string} text - The text string to count words from.
         * @returns {number} The word count.
         */
        function countWords(text) {
            if (!text) return 0;
            // Use a regex to match sequences of word characters (letters, numbers, underscore)
            // This typically ignores punctuation as separate words unless explicitly part of an alphanumeric sequence.
            const matches = text.match(/\b\w+\b/g);
            return matches ? matches.length : 0;
        }

        /**
         * Resolves a relative path against a base path, mimicking URL resolution.
         * Useful for handling paths within the ZIP archive that are relative to different files.
         * @param {string} basePath - The base directory path (e.g., 'OEBPS/').
         * @param {string} relativePath - The relative path to resolve (e.g., '../text/chapter1.xhtml').
         * @returns {string} The resolved absolute path relative to the ZIP root.
         */
        function resolvePath(basePath, relativePath) {
            if (basePath.length > 0 && basePath[basePath.length - 1] !== '/') {
                basePath += '/';
            }
            try {
                // Using 'dummy://' scheme to allow URL constructor to resolve relative file paths
                const resolvedUrl = new URL(relativePath, 'dummy://' + basePath);
                let path = resolvedUrl.pathname;
                if (path.startsWith('/')) path = path.substring(1); // Remove leading slash for ZIP entry names
                return path.split('#')[0]; // Remove fragment identifier (e.g., #intro)
            } catch (e) {
                console.error("Path resolution error:", e, "Base:", basePath, "Relative:", relativePath);
                return relativePath.split('#')[0]; // Fallback, remove fragment
            }
        }

        // --- UI Control Functions ---

        /** Enables interaction with all main reader control buttons. */
        function enableControls() {
            startButton.disabled = false;
            pauseResumeButton.disabled = false;
            prevButton.disabled = false;
            nextButton.disabled = false;
            resetSpotButton.disabled = false;
            chapterNavDiv.style.display = 'block';
        }

        /** Disables interaction with all main reader control buttons. */
        function disableControls() {
            startButton.disabled = true;
            pauseResumeButton.disabled = true;
            prevButton.disabled = true;
            nextButton.disabled = true;
            resetSpotButton.disabled = true;
            chapterNavDiv.style.display = 'none';
        }

        /** Clears the main display area and resets related UI elements. */
        function clearReaderDisplay() {
            outputDiv.innerHTML = 'Select an EPUB file to begin.';
            statusDiv.textContent = '';
            chapterNavDiv.innerHTML = '<h2>Chapters:</h2>';
            chapterNavDiv.style.display = 'none';
            stopBolding(); // Ensure bolding is stopped when display is cleared
            allParagraphs = []; // Clear content
            chapters = []; // Clear chapter data
            activeBookId = null; // No active book
        }

        /** Updates the status message displaying current chapter and paragraph. */
        function updateStatus() {
            if (allParagraphs.length === 0) {
                statusDiv.textContent = "No content loaded.";
            } else {
                let readingMode = isPlaying ? 'Auto-Advance' : 'Paused';
                statusDiv.textContent = `Chapter: ${chapters[currentChapterIndex]?.title || 'Unknown'} | Paragraph ${currentIndex + 1} of ${allParagraphs.length} (${readingMode})`;
                pauseResumeButton.textContent = isPlaying ? 'Pause' : 'Resume';
            }
        }

        /** Updates the display of the total words read. */
        function updateTotalWordsReadDisplay() {
            wordsReadDiv.textContent = `Total words read across all books: ${totalWordsRead.toLocaleString()}`;
        }

        // --- Local Storage Management for Saved Books ---

        /**
         * Retrieves the array of saved book objects from localStorage.
         * @returns {Array<object>} An array of saved book objects.
         */
        function getSavedBooks() {
            try {
                const storedBooks = localStorage.getItem(SAVED_BOOKS_KEY);
                return storedBooks ? JSON.parse(storedBooks) : [];
            } catch (e) {
                console.error("Error parsing saved books from localStorage:", e);
                return [];
            }
        }

        /**
         * Saves the current array of book objects to localStorage and updates the list display.
         * @param {Array<object>} books - The array of book objects to save.
         */
        function saveBooks(books) {
            localStorage.setItem(SAVED_BOOKS_KEY, JSON.stringify(books));
            renderSavedBooksList(); // Update the list display
        }

        /**
         * Saves the current reading spot (chapter and paragraph index) for the active book
         * into its corresponding entry in localStorage.
         */
        function saveCurrentBookSpot() {
            if (!activeBookId) return; // No book currently active to save a spot for

            const books = getSavedBooks();
            const bookIndex = books.findIndex(book => book.id === activeBookId);

            if (bookIndex !== -1) {
                books[bookIndex].lastReadSpot = {
                    chapterIndex: currentChapterIndex,
                    paragraphIndex: currentIndex
                };
                saveBooks(books);
            }
        }

        /** Loads the cumulative total words read from localStorage. */
        function loadTotalWordsRead() {
            const savedTotalWords = localStorage.getItem(TOTAL_WORDS_READ_KEY);
            if (savedTotalWords !== null) {
                const parsedTotal = parseInt(savedTotalWords, 10);
                if (!isNaN(parsedTotal) && parsedTotal >= 0) {
                    totalWordsRead = parsedTotal;
                } else {
                    totalWordsRead = 0;
                }
            } else {
                totalWordsRead = 0;
            }
            updateTotalWordsReadDisplay();
        }

        /**
         * Increments the total words read count based on the content of a paragraph.
         * @param {string} paragraphHTML - The HTML content of the paragraph.
         */
        function incrementTotalWordsRead(paragraphHTML) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = paragraphHTML;
            const wordsInParagraph = countWords(tempDiv.textContent || tempDiv.innerText || "");
            localStorage.setItem(TOTAL_WORDS_READ_KEY, totalWordsRead.toString());
            updateTotalWordsReadDisplay();
        }

        // --- Chapter Navigation ---

        /** Dynamically creates and displays buttons for each chapter. */
        function displayChapterButtons() {
            chapterNavDiv.innerHTML = '<h2>Chapters:</h2>'; // Clear existing buttons
            if (chapters.length > 0) {
                chapters.forEach((chapter, index) => {
                    const button = document.createElement('button');
                    button.textContent = chapter.title;
                    button.dataset.chapterIndex = index; // Store flat index for click handler
                    button.onclick = () => loadChapter(index);
                    // Add indentation based on level
                    button.style.marginLeft = `${chapter.level * 20}px`;
                    button.style.width = `calc(100% - ${chapter.level * 20}px)`;

                    if (index === currentChapterIndex) {
                        button.classList.add('active');
                    }
                    chapterNavDiv.appendChild(button);
                });
                chapterNavDiv.style.display = 'block';
            } else {
                chapterNavDiv.style.display = 'none';
            }
        }

        /** Highlights the button corresponding to the currently active chapter. */
        function highlightActiveChapterButton() {
            const chapterButtons = chapterNavDiv.querySelectorAll('button');
            chapterButtons.forEach((button, index) => {
                if (index === currentChapterIndex) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        /**
         * Loads and displays a specific chapter by its index in the flat `chapters` array.
         * @param {number} chapterIndex - The flat index of the chapter to load.
         */
        async function loadChapter(chapterIndex) {
            if (chapterIndex < 0 || chapterIndex >= chapters.length) return;

            pauseReading(); // Pause auto-advance timer
            stopBolding(); // Stop word bolding

            currentChapterIndex = chapterIndex;
            currentIndex = 0; // Always start at the beginning of the new chapter

            allParagraphs = chapters[currentChapterIndex].rawParagraphs || [];

            displayCurrentParagraph(); // Update main display with first paragraph of new chapter
            highlightActiveChapterButton(); // Update chapter button highlight
            saveCurrentBookSpot(); // Save the new chapter and paragraph spot for this book
        }

        // --- Word Bolding and Paragraph Display ---

        /** Clears any existing word highlights in the output div. */
        function clearHighlights() {
            const highlightedSpans = outputDiv.querySelectorAll('.bold-word');
            highlightedSpans.forEach(span => {
                span.classList.remove('bold-word');
            });
        }

        /**
         * Prepares a paragraph's HTML for highlighting by wrapping each word in a span.
         * @param {string} paragraphHtml - The original HTML content of the paragraph.
         * @returns {string} The paragraph HTML with words wrapped in spans.
         */
        function getParagraphWithSpans(paragraphHtml) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = paragraphHtml;
            const plainText = tempDiv.textContent || tempDiv.innerText || '';

            // This regex attempts to split by word boundaries, including punctuation attached to words.
            const words = plainText.match(/\b(\w+)\b|[^\s\w]+/g) || [];

            let htmlWithSpans = '';
            let charIndex = 0; // Tracks position in the plainText

            for (let i = 0; i < words.length; i++) {
                const word = words[i];
                const originalIndex = plainText.indexOf(word, charIndex);

                if (originalIndex === -1) { // Fallback, shouldn't happen with robust regex
                    htmlWithSpans += word;
                    charIndex += word.length;
                    continue;
                }

                // Add any non-word characters (like leading spaces or punctuation) before the word
                if (originalIndex > charIndex) {
                    htmlWithSpans += plainText.substring(charIndex, originalIndex);
                }

                // Wrap the word
                htmlWithSpans += `<span data-word-index="${i}">${word}</span>`;
                charIndex = originalIndex + word.length;
            }
            // Add any remaining text (e.g., trailing spaces)
            htmlWithSpans += plainText.substring(charIndex);

            return htmlWithSpans;
        }

        /** Advances the word bolding within the current paragraph. */
        function updateBolding() {
            totalWordsRead += 1; // Increment total words read for each word bolded
            localStorage.setItem(TOTAL_WORDS_READ_KEY, totalWordsRead.toString());
            updateTotalWordsReadDisplay(); // Update display of total words read
            const wordsSpans = outputDiv.querySelectorAll('span[data-word-index]');

            // Remove bold from previous word
            if (currentWordIndex > 0 && wordsSpans[currentWordIndex - 1]) {
                wordsSpans[currentWordIndex - 1].classList.remove('bold-word');
            }

            // Bold the current word
            if (currentWordIndex < wordsSpans.length) {
                wordsSpans[currentWordIndex].classList.add('bold-word');
                currentWordIndex++;
            } else {
                // End of paragraph, move to next
                stopBolding(); // Stop bolding for this paragraph
                showNextParagraph(); // Advance to the next paragraph
            }
        }

        /** Starts the word-by-word bolding animation. */
        function startBolding() {
            stopBolding(); // Ensure any existing bolding is stopped
            currentWordIndex = 0; // Reset word index for new paragraph

            if (allParagraphs.length === 0) return;

            // Display the current paragraph with spans, which clears old highlights
            displayCurrentParagraph();

            const wordsInCurrentParagraph = outputDiv.querySelectorAll('span[data-word-index]').length;
            if (wordsInCurrentParagraph === 0) {
                // If current paragraph is empty or has no words, just go to next
                showNextParagraph();
                return;
            }

            // Start interval for word bolding
            intervalId = setInterval(updateBolding, document.querySelector('#wpm').value / 60 * 1000); // Convert WPM to milliseconds per word
        }

        /** Stops the word-by-word bolding animation. */
        function stopBolding() {
            clearInterval(intervalId);
            intervalId = null;
            clearHighlights(); // Clear all highlights
            currentWordIndex = 0; // Reset word index
        }


        /** Displays the paragraph at the current `currentIndex`. */
        function displayCurrentParagraph() {
            clearHighlights(); // Clear highlights from previous paragraph

            if (allParagraphs.length === 0) {
                outputDiv.textContent = "No paragraphs to display for this chapter.";
                return;
            }
            if (currentIndex < 0) currentIndex = 0;
            if (currentIndex >= allParagraphs.length) currentIndex = allParagraphs.length - 1;

            const currentParagraphHTML = allParagraphs[currentIndex];
            // Prepare paragraph for highlighting by wrapping words in spans
            outputDiv.innerHTML = getParagraphWithSpans(currentParagraphHTML);

            incrementTotalWordsRead(currentParagraphHTML); // Increment total words read for this paragraph

            saveCurrentBookSpot(); // Save spot for the current book
            updateStatus();
        }

        /** Moves to and displays the next paragraph or chapter. */
        function showNextParagraph() {
            // Stop current bolding before moving to the next paragraph
            stopBolding();

            if (currentIndex < allParagraphs.length - 1) {
                currentIndex++;
            } else {
                // End of current chapter, try to go to next chapter
                if (currentChapterIndex < chapters.length - 1) {
                    loadChapter(currentChapterIndex + 1); // loadChapter will handle display
                    return; // Exit to prevent calling displayCurrentParagraph twice
                } else {
                    // End of book
                    pauseReading(); // Stop auto-advance
                    alert("End of book reached!");
                    currentIndex = allParagraphs.length - 1; // Stay at the last paragraph
                }
            }
            displayCurrentParagraph(); // Update display
            // If auto-advance (isPlaying) is active, restart word bolding for the new paragraph
            if (isPlaying) {
                startBolding();
            }
        }

        /** Moves to and displays the previous paragraph or chapter. */
        function showPrevParagraph() {
            // Stop current bolding before moving to the previous paragraph
            stopBolding();

            if (currentIndex > 0) {
                currentIndex--;
            } else {
                // Beginning of current chapter, try to go to previous chapter
                if (currentChapterIndex > 0) {
                    loadChapter(currentChapterIndex - 1);
                    // Set current index to the last paragraph of the previous chapter
                    currentIndex = chapters[currentChapterIndex].rawParagraphs.length - 1;
                } else {
                    alert("Already at the beginning of the book!");
                }
            }
            displayCurrentParagraph(); // Update display
            // If auto-advance (isPlaying) is active, restart word bolding for the new paragraph
            if (isPlaying) {
                startBolding();
            }
        }

        // --- Reading Controls ---

        /** Initiates or restarts the auto-advance reading mode. */
        function startReading() {
            if (isPlaying || allParagraphs.length === 0) return;

            isPlaying = true;
            updateStatus();
            startBolding(); // Start the word-by-word bolding
        }

        /** Pauses the auto-advance reading mode. */
        function pauseReading() {
            if (!isPlaying) return;
            isPlaying = false;
            stopBolding(); // Stop word bolding
            saveCurrentBookSpot();
            updateStatus();
        }

        /** Resumes the auto-advance reading mode. */
        function resumeReading() {
            if (isPlaying || allParagraphs.length === 0) return;
            isPlaying = true;
            updateStatus();
            startBolding(); // Resume word bolding
        }

        /** Toggles between pause and resume for auto-advance. */
        function togglePauseResume() {
            if (allParagraphs.length === 0) return;

            if (isPlaying) {
                pauseReading();
            } else {
                resumeReading();
            }
        }

        /** Resets the reading spot for the currently loaded book to the beginning. */
        function resetReadingSpot() {
            if (!activeBookId || chapters.length === 0) return;
            if (confirm("Are you sure you want to reset your reading spot for this book to the beginning?")) {
                pauseReading(); // Pause auto-advance
                currentChapterIndex = 0;
                currentIndex = 0;
                saveCurrentBookSpot(); // Update saved spot in localStorage
                loadChapter(0); // Reload first chapter to update display
            }
        }

        /** Resets the total words read count across all books. */
        function resetTotalWordsRead() {
            if (confirm("Are you sure you want to reset the TOTAL words read across all books? This cannot be undone.")) {
                totalWordsRead = 0;
                localStorage.setItem(TOTAL_WORDS_READ_KEY, '0');
                updateTotalWordsReadDisplay();
            }
        }

        // --- Keyboard Listener for Spacebar ---
        document.addEventListener('keydown', (event) => {
            if (event.code === 'Space') {
                event.preventDefault(); // Prevent default browser action (scrolling)
                togglePauseResume();
            }
            if (event.code === 'ArrowRight') {
                event.preventDefault();
                showNextParagraph();
            }
            if (event.code === 'ArrowLeft') {
                event.preventDefault();
                showPrevParagraph();
            }
        });

        // --- Main EPUB Processing ---

        /**
         * Parses the NCX (EPUB2) Table of Contents recursively.
         * @param {Element} navPointElement - The current <navPoint> element.
         * @param {string} tocBaseDir - The base directory of the NCX file.
         * @param {number} level - The current nesting level.
         * @param {object} tocOrderCounter - An object to keep track of a flat order counter (passed by reference).
         */
        function parseNcxNavPoints(navPointElement, tocBaseDir, level, tocOrderCounter) {
            const navLabel = navPointElement.querySelector('navLabel text');
            const content = navPointElement.querySelector('content');

            if (navLabel && content) {
                const title = navLabel.textContent.trim();
                let src = content.getAttribute('src');

                if (src) {
                    const fullChapterHref = resolvePath(tocBaseDir, src);
                    const cleanHref = fullChapterHref.split('#')[0]; // Remove fragment identifiers

                    // Only add if this is a new, unique content file
                    if (!chapters.some(ch => ch.href === cleanHref)) {
                        chapters.push({
                            title: title,
                            href: cleanHref,
                            rawParagraphs: [], // Will be filled later
                            level: level,
                            tocOrder: tocOrderCounter.value++ // Use .value for mutable counter
                        });
                    }
                }
            }

            // Recursively parse child navPoints
            Array.from(navPointElement.children).filter(child => child.tagName === 'navPoint').forEach(childNavPoint => {
                parseNcxNavPoints(childNavPoint, tocBaseDir, level + 1, tocOrderCounter);
            });
        }

        /**
         * Parses the EPUB3 Nav Document (Table of Contents) recursively.
         * @param {Element} liElement - The current <li> element (or its <a> if starting).
         * @param {string} tocBaseDir - The base directory of the Nav Document.
         * @param {number} level - The current nesting level.
         * @param {object} tocOrderCounter - An object to keep track of a flat order counter (passed by reference).
         */
        function parseNavDocLiElements(liElement, tocBaseDir, level, tocOrderCounter) {
            const link = liElement.querySelector('a'); // Get the direct link within this li
            if (link) {
                const title = link.textContent.trim();
                let href = link.getAttribute('href');

                if (href) {
                    const fullChapterHref = resolvePath(tocBaseDir, href);
                    const cleanHref = fullChapterHref.split('#')[0];

                    if (!chapters.some(ch => ch.href === cleanHref)) {
                        chapters.push({
                            title: title,
                            href: cleanHref,
                            rawParagraphs: [],
                            level: level,
                            tocOrder: tocOrderCounter.value++ // Use .value for mutable counter
                        });
                    }
                }
            }

            // Find nested <ul> elements and iterate their <li> children
            const nestedUl = liElement.querySelector('ul');
            if (nestedUl) {
                Array.from(nestedUl.children).filter(child => child.tagName === 'li').forEach(childLi => {
                    parseNavDocLiElements(childLi, tocBaseDir, level + 1, tocOrderCounter);
                });
            }
        }


        /**
         * Loads and processes a new EPUB file from the file input.
         * This function will either load an already saved book or parse a new one.
         */
        async function processEpub() {
            outputDiv.textContent = 'Loading EPUB...';
            messageDiv.style.display = 'none';
            disableControls();
            pauseReading();
            clearReaderDisplay(); // Clear any previous book's display

            const fileInput = document.getElementById('epubFile');
            if (!fileInput.files.length) {
                outputDiv.textContent = 'Please select an EPUB file.';
                return;
            }

            const file = fileInput.files[0];
            const fileInfo = {
                name: file.name,
                size: file.size,
                lastModified: file.lastModified,
                timestamp: new Date().toISOString()
            };
            const newBookId = generateBookId(fileInfo);

            let savedBooks = getSavedBooks();
            const existingBook = savedBooks.find(book => book.id === newBookId);

            if (existingBook) {
                messageDiv.innerHTML = `<p>Book "<strong>${fileInfo.name}</strong>" is already saved. Loading from your last spot.</p>`;
                messageDiv.style.display = 'block';
                await loadBookDataIntoReader(existingBook); // Directly load from saved data
                fileInput.value = ''; // Clear file input after loading
                return;
            }

            // If it's a new book, proceed with parsing
            activeBookId = null; // Clear active book ID until successfully processed
            chapters = []; // Reset chapters for new parse

            try {
                const arrayBuffer = await file.arrayBuffer();
                const zip = new JSZip();
                await zip.loadAsync(arrayBuffer);

                let opfPath = null;
                let opfBaseDir = ''; // Directory of content.opf within the zip

                const containerXmlFile = zip.file('META-INF/container.xml');
                if (!containerXmlFile) throw new Error("META-INF/container.xml not found.");
                const containerXmlContent = await containerXmlFile.async('string');
                const parser = new DOMParser();
                const containerDoc = parser.parseFromString(containerXmlContent, 'application/xml');
                const rootfileElement = containerDoc.querySelector('rootfile[media-type="application/oebps-package+xml"]');

                if (rootfileElement) {
                    opfPath = rootfileElement.getAttribute('full-path');
                    opfBaseDir = opfPath.substring(0, opfPath.lastIndexOf('/') + 1);
                } else {
                    throw new Error("OPF file not found in container.xml.");
                }

                const opfFile = zip.file(opfPath);
                if (!opfFile) throw new Error(`OPF file not found: ${opfPath}`);
                const opfContent = await opfFile.async('string');
                const opfDoc = parser.parseFromString(opfContent, 'application/xml');

                const manifestItems = opfDoc.querySelectorAll('manifest item');
                const idToHrefMap = new Map(); // Store ID to Href mapping for spine fallback
                manifestItems.forEach(item => {
                    const id = item.getAttribute('id');
                    const href = item.getAttribute('href');
                    idToHrefMap.set(id, href);
                });

                let tocHref = null;
                let isNavDoc = false;
                const navItem = opfDoc.querySelector('manifest item[properties="nav"]');
                if (navItem) {
                    tocHref = navItem.getAttribute('href');
                    isNavDoc = true;
                } else {
                    const ncxItem = opfDoc.querySelector('manifest item[id="ncx"][media-type="application/x-dtbncx+xml"]');
                    if (ncxItem) {
                        tocHref = ncxItem.getAttribute('href');
                    } else {
                        console.warn("No standard TOC found. Attempting to use spine as chapters.");
                    }
                }

                let tocContent = null;
                let tocBaseDir = opfBaseDir; // Default to opfBaseDir for resolving TOC hrefs
                if (tocHref) {
                    tocBaseDir = resolvePath(opfBaseDir, tocHref); // Get full path of TOC file
                    tocBaseDir = tocBaseDir.substring(0, tocBaseDir.lastIndexOf('/') + 1); // Get its directory

                    const tocFile = zip.file(resolvePath(opfBaseDir, tocHref));
                    if (tocFile) {
                        tocContent = await tocFile.async('string');
                    } else {
                        console.warn(`TOC file not found in ZIP: ${resolvePath(opfBaseDir, tocHref)}`);
                    }
                }

                let tocOrderCounter = { value: 0 }; // Use object to pass by reference for mutation in recursion

                if (tocContent && isNavDoc) {
                    const navDoc = parser.parseFromString(tocContent, 'text/html');
                    const navToc = navDoc.querySelector('nav[epub\\:type="toc"], nav[type="toc"]');
                    if (navToc) {
                        // Find top-level <li> elements within the navToc
                        Array.from(navToc.children).filter(child => child.tagName === 'ol' || child.tagName === 'ul').forEach(olOrUl => {
                            Array.from(olOrUl.children).filter(child => child.tagName === 'li').forEach(topLi => {
                                parseNavDocLiElements(topLi, tocBaseDir, 0, tocOrderCounter); // Start level at 0
                            });
                        });
                    }
                } else if (tocContent && !isNavDoc) {
                    const ncxDoc = parser.parseFromString(tocContent, 'application/xml');
                    const navMap = ncxDoc.querySelector('navMap');
                    if (navMap) {
                        Array.from(navMap.children).filter(child => child.tagName === 'navPoint').forEach(topNavPoint => {
                            parseNcxNavPoints(topNavPoint, tocBaseDir, 0, tocOrderCounter); // Start level at 0
                        });
                    }
                }

                // Fallback: If no TOC or empty TOC, use spine items as chapters (flat structure)
                if (chapters.length === 0) {
                    console.warn("Falling back to spine order for chapters as TOC was not found or empty.");
                    const spineItems = opfDoc.querySelectorAll('spine itemref');
                    let fallbackChapterCounter = 1;
                    for (const itemRef of spineItems) {
                        const idRef = itemRef.getAttribute('idref');
                        const href = idToHrefMap.get(idRef); // Href is relative to OPF file
                        if (href && (href.endsWith('.xhtml') || href.endsWith('.html'))) {
                            const cleanHref = resolvePath(opfBaseDir, href);
                            // Only add if this is a new, unique content file
                            if (!chapters.some(ch => ch.href === cleanHref)) {
                                chapters.push({
                                    title: `Chapter ${fallbackChapterCounter++}`,
                                    href: cleanHref,
                                    rawParagraphs: [],
                                    level: 0, // No hierarchy in fallback
                                    tocOrder: tocOrderCounter.value++
                                });
                            }
                        }
                    }
                }

                // Sort chapters by tocOrder to ensure correct reading order even if TOC parsing was out of order
                chapters.sort((a, b) => a.tocOrder - b.tocOrder);

                // Now, load and parse paragraphs for each chapter based on its resolved full path
                for (let i = 0; i < chapters.length; i++) {
                    const chapter = chapters[i];
                    // The chapter.href is now already the full path relative to ZIP root
                    const htmlFile = zip.file(chapter.href);

                    if (htmlFile) {
                        const htmlContent = await htmlFile.async('string');
                        const htmlDoc = parser.parseFromString(htmlContent, 'text/html');
                        const pElements = htmlDoc.querySelectorAll('p');
                        const chapterParagraphs = [];
                        pElements.forEach(p => {
                            const text = p.textContent.trim();
                            if (text) {
                                chapterParagraphs.push(`<p>${text}</p>`);
                            }
                        });
                        chapter.rawParagraphs = chapterParagraphs;
                    } else {
                        console.warn(`Warning: Chapter HTML file not found in ZIP: ${chapter.href}`);
                        chapter.rawParagraphs = []; // No paragraphs for this chapter
                    }
                }

                chapters = chapters.filter(ch => ch.rawParagraphs && ch.rawParagraphs.length > 0);

                if (chapters.length > 0) {
                    const newBook = {
                        id: newBookId,
                        metadata: fileInfo,
                        chapters: chapters, // Save the entire detailed chapters array
                        lastReadSpot: { chapterIndex: 0, paragraphIndex: 0 } // Default to start of book
                    };

                    // Add/update this book in the saved books list
                    if (existingBook) { // Use existingBook directly
                        const existingBookIndex = savedBooks.findIndex(book => book.id === existingBook.id);
                        savedBooks[existingBookIndex] = newBook;
                    } else {
                        savedBooks.push(newBook);
                    }
                    saveBooks(savedBooks);

                    await loadBookDataIntoReader(newBook);
                    fileInput.value = '';
                } else {
                    outputDiv.textContent = "No readable chapters or paragraphs found in this EPUB.";
                    disableControls();
                    activeBookId = null;
                }

            } catch (error) {
                outputDiv.textContent = `Error processing EPUB: ${error.message}`;
                console.error(error);
                allParagraphs = [];
                chapters = [];
                activeBookId = null;
                disableControls();
            }
        }

        // --- Load a previously saved book into the reader ---
        async function loadBookDataIntoReader(book) {
            pauseReading(); // Stop any currently playing book
            stopBolding(); // Stop any active bolding

            activeBookId = book.id;
            chapters = book.chapters; // Load the detailed chapters array

            // Load saved spot or default to beginning
            const spot = book.lastReadSpot || { chapterIndex: 0, paragraphIndex: 0 };
            currentChapterIndex = spot.chapterIndex;
            currentIndex = spot.paragraphIndex;

            // Ensure the loaded chapter index is valid
            if (currentChapterIndex < 0 || currentChapterIndex >= chapters.length) {
                currentChapterIndex = 0;
            }
            allParagraphs = chapters[currentChapterIndex]?.rawParagraphs || [];

            // Ensure the loaded paragraph index is valid
            if (currentIndex < 0 || currentIndex >= allParagraphs.length) {
                currentIndex = 0;
            }

            if (allParagraphs.length > 0) {
                displayCurrentParagraph(); // Update reader display
                displayChapterButtons(); // Show chapter list for this book (with hierarchy)
                highlightActiveChapterButton(); // Highlight current chapter
                enableControls(); // Enable reader controls
                startButton.disabled = false; // Only enable start button initially
                pauseResumeButton.disabled = true; // Disabled until start is pressed
            } else {
                outputDiv.textContent = `No readable content found for "${book.metadata.name}" in saved data.`;
                disableControls();
            }
            updateStatus();
        }

        // --- Saved Books List Management ---

        /** Renders the list of saved books in the UI. */
        function renderSavedBooksList() {
            savedBooksContainer.innerHTML = ''; // Clear current list
            const books = getSavedBooks();

            if (books.length === 0) {
                savedBooksContainer.innerHTML = '<p>No books saved yet. Load an EPUB above!</p>';
                return;
            }

            books.forEach(book => {
                const bookItem = document.createElement('div');
                bookItem.classList.add('saved-book-item');

                const bookInfo = document.createElement('span');
                bookInfo.textContent = book.metadata.name;
                bookItem.appendChild(bookInfo);

                const loadButton = document.createElement('button');
                loadButton.textContent = 'Load';
                loadButton.onclick = () => loadBookDataIntoReader(book);
                bookItem.appendChild(loadButton);

                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'Delete';
                deleteButton.onclick = () => deleteSavedBook(book.id);
                bookItem.appendChild(deleteButton);

                savedBooksContainer.appendChild(bookItem);
            });
        }

        /**
         * Deletes a specific book from the saved list.
         * @param {string} bookId - The ID of the book to delete.
         */
        function deleteSavedBook(bookId) {
            if (confirm("Are you sure you want to delete this book from your saved list?")) {
                let books = getSavedBooks();
                books = books.filter(book => book.id !== bookId);
                saveBooks(books); // Save updated list

                if (activeBookId === bookId) {
                    // If the deleted book was currently active, clear the reader
                    activeBookId = null;
                    allParagraphs = [];
                    chapters = [];
                    currentIndex = 0;
                    currentChapterIndex = 0;
                    pauseReading(); // Stop any active reading
                    stopBolding(); // Stop bolding
                    clearReaderDisplay();
                    disableControls();
                    updateStatus();
                }
            }
        }

        /** Clears all saved books from localStorage. */
        function clearAllSavedBooks() {
            if (confirm("Are you sure you want to clear ALL saved books? This cannot be undone.")) {
                localStorage.removeItem(SAVED_BOOKS_KEY);
                renderSavedBooksList(); // Update UI
                // Also clear the currently active book if any
                activeBookId = null;
                allParagraphs = [];
                chapters = [];
                currentIndex = 0;
                currentChapterIndex = 0;
                pauseReading();
                stopBolding();
                clearReaderDisplay();
                disableControls();
                updateStatus();
            }
        }

        // --- Initial Application Load ---
        function initializeReader() {
            loadTotalWordsRead();
            renderSavedBooksList(); // Display saved books list on load
            clearReaderDisplay(); // Clear reader area initially
            disableControls(); // Disable controls until a book is loaded
            updateStatus();

            // Auto-load the "last used" book if available from the new saved books list
            const savedBooks = getSavedBooks();
            if (savedBooks.length > 0) {
                // Try to find the book that was last processed
                const lastSelectedInfo = localStorage.getItem('lastSelectedEpubFile'); // Old key for the "last processed" file
                let bookToAutoLoad = null;

                if (lastSelectedInfo) {
                    try {
                        const fileInfo = JSON.parse(lastSelectedInfo);
                        const lastBookId = generateBookId(fileInfo);
                        bookToAutoLoad = savedBooks.find(b => b.id === lastBookId);
                    } catch (e) {
                        console.warn("Failed to parse old lastSelectedEpubFile, auto-loading first book.", e);
                    }
                }

                // If not found (e.g., deleted), or no previous, load the first book
                if (!bookToAutoLoad) {
                    bookToAutoLoad = savedBooks[0];
                }

                if (bookToAutoLoad) {
                    loadBookDataIntoReader(bookToAutoLoad);
                    messageDiv.innerHTML = `<p>Automatically loaded "<strong>${bookToAutoLoad.metadata.name}</strong>".</p>`;
                    messageDiv.style.display = 'block';
                }
            }

            // Cleanup old localStorage keys (run once, then can be removed from code)
            localStorage.removeItem('lastSelectedEpubFile');
            localStorage.removeItem('lastProcessedEpubParagraphs');
            localStorage.removeItem('epubReaderCurrentSpot');
            localStorage.removeItem('epubReaderCurrentChapter');
        }

        // --- Event Listeners for Initial Load and Unload ---
        window.addEventListener('load', initializeReader);
        window.addEventListener('beforeunload', () => {
            saveCurrentBookSpot(); // Save current book's spot when leaving the page
            stopBolding(); // Stop bolding when leaving the page
        });
    </script>
</body>

</html>