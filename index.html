<!DOCTYPE html>
<html>
<head>
    <title>EEEReader</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body { font-family: sans-serif; margin: 20px; }
        #message { margin-top: 10px; padding: 10px; border: 1px solid #ccc; background-color: #f9f9f9; display: none; }
        #output {
            white-space: pre-wrap;
            word-wrap: break-word;
            min-height: 100px;
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #eee;
            padding: 10px;
            background-color: #fff;
            margin-top: 20px;
            font-size: 1.1em;
            line-height: 1.6;
        }
        #controls { margin-top: 15px; }
        #status { margin-top: 10px; font-weight: bold; }
        #wordsReadDiv { margin-top: 10px; font-style: italic; color: #555; }
        button { padding: 8px 15px; margin-right: 10px; cursor: pointer; }
        input[type="file"] { margin-right: 10px; }

        #chapterNav {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #ddd;
            background-color: #f0f0f0;
            max-height: 200px;
            overflow-y: auto;
            display: none; /* Hidden by default */
        }
        #chapterNav button {
            display: block; /* Each chapter button on its own line */
            width: 100%;
            text-align: left;
            padding: 8px 10px;
            margin-bottom: 5px;
            background-color: #e0e0e0;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
            white-space: nowrap; /* Prevent chapter titles from wrapping */
            overflow: hidden;
            text-overflow: ellipsis; /* Add ellipsis for long titles */
        }
        #chapterNav button:hover {
            background-color: #d0d0d0;
        }
        #chapterNav button.active {
            background-color: #4CAF50; /* Highlight active chapter */
            color: white;
            border-color: #4CAF50;
        }
    </style>
</head>
<body>
    <h1>EPUB Paragraph Reader</h1>

    <div id="message"></div>

    <input type="file" id="epubFile" accept=".epub">
    <button onclick="processEpub()">Load & Process EPUB</button>

    <div id="controls">
        <button id="startButton" onclick="startReading()" disabled>Start Reading</button>
        <button id="pauseResumeButton" onclick="togglePauseResume()" disabled>Pause</button>
        <button id="prevButton" onclick="showPrevParagraph()" disabled>&lt; Previous</button>
        <button id="nextButton" onclick="showNextParagraph()" disabled>Next &gt;</button>
        <button id="resetSpotButton" onclick="resetReadingSpot()" disabled>Reset Spot (Current Book)</button>
        <button id="resetTotalWordsButton" onclick="resetTotalWordsRead()">Reset Total Words (All Books)</button>
    </div>

    <div id="status"></div>
    <div id="wordsReadDiv"></div>

    <div id="chapterNav">
        <h2>Chapters:</h2>
        </div>

    <div id="output"></div>

    <script>
        const LAST_SELECTED_FILE_KEY = 'lastSelectedEpubFile';
        const LAST_PROCESSED_PARAGRAPHS_KEY = 'lastProcessedEpubParagraphs';
        const CURRENT_READER_SPOT_KEY = 'epubReaderCurrentSpot';
        const TOTAL_WORDS_READ_KEY = 'totalWordsRead';
        const CURRENT_CHAPTER_SPOT_KEY = 'epubReaderCurrentChapter'; // New key for current chapter

        let allParagraphs = []; // Paragraphs of the currently loaded chapter
        let currentIndex = 0; // Current paragraph index within the loaded chapter
        let currentChapterIndex = 0; // Index of the currently loaded chapter in `chapters` array
        let isPlaying = false;
        let intervalId = null;
        const displayInterval = 5000; // 5 seconds
        const initialDelay = 2000; // 2 seconds before starting

        let totalWordsRead = 0;
        let chapters = []; // Array to store chapter { title, href, rawParagraphs }

        const outputDiv = document.getElementById('output');
        const messageDiv = document.getElementById('message');
        const statusDiv = document.getElementById('status');
        const wordsReadDiv = document.getElementById('wordsReadDiv');
        const chapterNavDiv = document.getElementById('chapterNav'); // New chapter nav div
        const startButton = document.getElementById('startButton');
        const pauseResumeButton = document.getElementById('pauseResumeButton');
        const prevButton = document.getElementById('prevButton');
        const nextButton = document.getElementById('nextButton');
        const resetSpotButton = document.getElementById('resetSpotButton');
        const resetTotalWordsButton = document.getElementById('resetTotalWordsButton');

        // --- Utility Functions ---
        function countWords(text) {
            if (!text) return 0;
            const words = text.trim().split(/\s+/);
            return words.filter(word => word.length > 0).length;
        }

        // --- UI Control Functions ---
        function enableControls() {
            startButton.disabled = false;
            pauseResumeButton.disabled = false;
            prevButton.disabled = false;
            nextButton.disabled = false;
            resetSpotButton.disabled = false;
            chapterNavDiv.style.display = 'block'; // Show chapter navigation
        }

        function disableControls() {
            startButton.disabled = true;
            pauseResumeButton.disabled = true;
            prevButton.disabled = true;
            nextButton.disabled = true;
            resetSpotButton.disabled = true;
            chapterNavDiv.style.display = 'none'; // Hide chapter navigation
        }

        function updateStatus() {
            if (allParagraphs.length === 0) {
                statusDiv.textContent = "No content loaded.";
            } else {
                statusDiv.textContent = `Chapter: ${chapters[currentChapterIndex]?.title || 'Unknown'} | Paragraph ${currentIndex + 1} of ${allParagraphs.length} (${isPlaying ? 'Playing' : 'Paused'})`;
                pauseResumeButton.textContent = isPlaying ? 'Pause' : 'Resume';
            }
        }

        function updateTotalWordsReadDisplay() {
            wordsReadDiv.textContent = `Total words read across all books: ${totalWordsRead.toLocaleString()}`;
        }

        function saveReadingSpot() {
            localStorage.setItem(CURRENT_READER_SPOT_KEY, currentIndex.toString());
            localStorage.setItem(CURRENT_CHAPTER_SPOT_KEY, currentChapterIndex.toString());
        }

        function loadReadingSpot() {
            const savedSpot = localStorage.getItem(CURRENT_READER_SPOT_KEY);
            const savedChapter = localStorage.getItem(CURRENT_CHAPTER_SPOT_KEY);

            if (savedChapter !== null && allParagraphs.length > 0) {
                const parsedChapter = parseInt(savedChapter, 10);
                if (!isNaN(parsedChapter) && parsedChapter >= 0 && parsedChapter < chapters.length) {
                    currentChapterIndex = parsedChapter;
                    // Now, load the paragraphs for this chapter
                    allParagraphs = chapters[currentChapterIndex].rawParagraphs || [];
                    displayCurrentParagraph(); // Display current paragraph to update word count etc.
                } else {
                    currentChapterIndex = 0; // Reset chapter if invalid
                    allParagraphs = chapters[0]?.rawParagraphs || [];
                }
            } else {
                currentChapterIndex = 0;
                allParagraphs = chapters[0]?.rawParagraphs || [];
            }


            if (savedSpot !== null && allParagraphs.length > 0) { // Check allParagraphs.length again after chapter load
                const parsedSpot = parseInt(savedSpot, 10);
                if (!isNaN(parsedSpot) && parsedSpot >= 0 && parsedSpot < allParagraphs.length) {
                    currentIndex = parsedSpot;
                } else {
                    currentIndex = 0; // Reset if invalid spot
                }
            } else {
                currentIndex = 0;
            }
        }

        function loadTotalWordsRead() {
            const savedTotalWords = localStorage.getItem(TOTAL_WORDS_READ_KEY);
            if (savedTotalWords !== null) {
                const parsedTotal = parseInt(savedTotalWords, 10);
                if (!isNaN(parsedTotal) && parsedTotal >= 0) {
                    totalWordsRead = parsedTotal;
                } else {
                    totalWordsRead = 0;
                }
            } else {
                totalWordsRead = 0;
            }
            updateTotalWordsReadDisplay();
        }

        function incrementTotalWordsRead(paragraphHTML) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = paragraphHTML;
            const wordsInParagraph = countWords(tempDiv.textContent || tempDiv.innerText || "");
            totalWordsRead += wordsInParagraph;
            localStorage.setItem(TOTAL_WORDS_READ_KEY, totalWordsRead.toString());
            updateTotalWordsReadDisplay();
        }

        // --- Chapter Navigation ---
        function displayChapterButtons() {
            chapterNavDiv.innerHTML = '<h2>Chapters:</h2>'; // Clear existing
            if (chapters.length > 0) {
                chapters.forEach((chapter, index) => {
                    const button = document.createElement('button');
                    button.textContent = chapter.title;
                    button.dataset.chapterIndex = index; // Store index for click handler
                    button.onclick = () => loadChapter(index);
                    if (index === currentChapterIndex) {
                        button.classList.add('active');
                    }
                    chapterNavDiv.appendChild(button);
                });
                chapterNavDiv.style.display = 'block';
            } else {
                chapterNavDiv.style.display = 'none';
            }
        }

        function highlightActiveChapterButton() {
            const chapterButtons = chapterNavDiv.querySelectorAll('button');
            chapterButtons.forEach((button, index) => {
                if (index === currentChapterIndex) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        async function loadChapter(chapterIndex) {
            if (chapterIndex < 0 || chapterIndex >= chapters.length) return;
            if (chapterIndex === currentChapterIndex) { // Already on this chapter
                 displayCurrentParagraph(); // Just re-display if already on it
                 return;
            }

            pauseReading(); // Pause current reading
            currentChapterIndex = chapterIndex;
            currentIndex = 0; // Start at the beginning of the new chapter

            // Retrieve paragraphs for the new chapter
            allParagraphs = chapters[currentChapterIndex].rawParagraphs || [];

            displayCurrentParagraph(); // Show first paragraph of new chapter
            highlightActiveChapterButton(); // Update button highlight
            saveReadingSpot(); // Save the new chapter and paragraph spot
        }

        // --- Paragraph Display and Navigation ---
        function displayCurrentParagraph() {
            if (allParagraphs.length === 0) {
                outputDiv.textContent = "No paragraphs to display for this chapter.";
                return;
            }
            if (currentIndex < 0) currentIndex = 0;
            if (currentIndex >= allParagraphs.length) currentIndex = allParagraphs.length - 1;

            const currentParagraphHTML = allParagraphs[currentIndex];
            outputDiv.innerHTML = currentParagraphHTML;

            incrementTotalWordsRead(currentParagraphHTML); // Count words for this paragraph

            saveReadingSpot();
            updateStatus();
        }

        function showNextParagraph() {
            if (currentIndex < allParagraphs.length - 1) {
                currentIndex++;
            } else {
                // End of current chapter, try to go to next chapter
                if (currentChapterIndex < chapters.length - 1) {
                    loadChapter(currentChapterIndex + 1);
                } else {
                    // End of book
                    pauseReading();
                    alert("End of book reached!");
                    currentIndex = allParagraphs.length - 1;
                }
            }
            displayCurrentParagraph(); // Always call to update display and status
        }

        function showPrevParagraph() {
            if (currentIndex > 0) {
                currentIndex--;
            } else {
                // Beginning of current chapter, try to go to previous chapter
                if (currentChapterIndex > 0) {
                    loadChapter(currentChapterIndex - 1);
                    currentIndex = chapters[currentChapterIndex].rawParagraphs.length - 1; // Go to end of prev chapter
                } else {
                    alert("Already at the beginning of the book!");
                }
            }
            displayCurrentParagraph();
        }

        // --- Reading Controls ---
        function startReading() {
            if (isPlaying || allParagraphs.length === 0) return;

            isPlaying = true;
            updateStatus();
            displayCurrentParagraph();

            setTimeout(() => {
                if (isPlaying) {
                    intervalId = setInterval(showNextParagraph, displayInterval);
                }
            }, initialDelay);
        }

        function pauseReading() {
            if (!isPlaying) return;
            isPlaying = false;
            clearInterval(intervalId);
            intervalId = null;
            saveReadingSpot();
            updateStatus();
        }

        function resumeReading() {
            if (isPlaying || allParagraphs.length === 0) return;
            isPlaying = true;
            updateStatus();
            displayCurrentParagraph();
            intervalId = setInterval(showNextParagraph, displayInterval);
        }

        function togglePauseResume() {
            if (allParagraphs.length === 0) return;
            if (isPlaying) {
                pauseReading();
            } else {
                resumeReading();
            }
        }

        function resetReadingSpot() {
            if (confirm("Are you sure you want to reset your reading spot for this book to the beginning?")) {
                pauseReading();
                currentChapterIndex = 0;
                currentIndex = 0;
                localStorage.removeItem(CURRENT_READER_SPOT_KEY);
                localStorage.removeItem(CURRENT_CHAPTER_SPOT_KEY);
                loadChapter(0); // Load first chapter
            }
        }

        function resetTotalWordsRead() {
            if (confirm("Are you sure you want to reset the TOTAL words read across all books? This cannot be undone.")) {
                totalWordsRead = 0;
                localStorage.setItem(TOTAL_WORDS_READ_KEY, '0');
                updateTotalWordsReadDisplay();
            }
        }

        // --- Keyboard Listener for Spacebar ---
        document.addEventListener('keydown', (event) => {
            if (event.code === 'Space') {
                event.preventDefault();
                togglePauseResume();
            }
        });

        // --- EPUB Parsing Logic (Heavily modified for chapters) ---
        async function processEpub() {
            outputDiv.textContent = 'Loading EPUB...';
            messageDiv.style.display = 'none';
            disableControls();
            pauseReading();

            const fileInput = document.getElementById('epubFile');
            if (!fileInput.files.length) {
                outputDiv.textContent = 'Please select an EPUB file.';
                return;
            }

            const file = fileInput.files[0];
            allParagraphs = [];
            chapters = []; // Reset chapters array for new book

            try {
                // Store file metadata in localStorage
                localStorage.setItem(LAST_SELECTED_FILE_KEY, JSON.stringify({
                    name: file.name,
                    size: file.size,
                    lastModified: file.lastModified,
                    timestamp: new Date().toISOString()
                }));
                localStorage.removeItem(LAST_PROCESSED_PARAGRAPHS_KEY);
                localStorage.removeItem(CURRENT_READER_SPOT_KEY);
                localStorage.removeItem(CURRENT_CHAPTER_SPOT_KEY);

                const arrayBuffer = await file.arrayBuffer();
                const zip = new JSZip();
                await zip.loadAsync(arrayBuffer);

                let opfPath = null;
                let opfBaseDir = '';

                // Find container.xml
                const containerXmlFile = zip.file('META-INF/container.xml');
                if (!containerXmlFile) throw new Error("META-INF/container.xml not found.");
                const containerXmlContent = await containerXmlFile.async('string');
                const parser = new DOMParser();
                const containerDoc = parser.parseFromString(containerXmlContent, 'application/xml');
                const rootfileElement = containerDoc.querySelector('rootfile[media-type="application/oebps-package+xml"]');

                if (rootfileElement) {
                    opfPath = rootfileElement.getAttribute('full-path');
                    opfBaseDir = opfPath.substring(0, opfPath.lastIndexOf('/') + 1);
                } else {
                    throw new Error("OPF file not found in container.xml.");
                }

                // Load and parse content.opf
                const opfFile = zip.file(opfPath);
                if (!opfFile) throw new Error(`OPF file not found: ${opfPath}`);
                const opfContent = await opfFile.async('string');
                const opfDoc = parser.parseFromString(opfContent, 'application/xml');

                const manifestItems = opfDoc.querySelectorAll('manifest item');
                const idToHrefMap = new Map(); // id -> href (relative path)
                const hrefToIdMap = new Map(); // href (relative path) -> id
                manifestItems.forEach(item => {
                    const id = item.getAttribute('id');
                    const href = item.getAttribute('href');
                    const mediaType = item.getAttribute('media-type');
                    idToHrefMap.set(id, href);
                    hrefToIdMap.set(href, id);
                });

                // Try to find the TOC (NCX for EPUB2 or Nav Document for EPUB3)
                let tocHref = null;
                let isNavDoc = false;
                // EPUB3 Nav Document: item with media-type="application/xhtml+xml" and properties="nav"
                const navItem = opfDoc.querySelector('manifest item[properties="nav"]');
                if (navItem) {
                    tocHref = navItem.getAttribute('href');
                    isNavDoc = true;
                } else {
                    // EPUB2 NCX: item with id="ncx" and media-type="application/x-dtbncx+xml"
                    const ncxItem = opfDoc.querySelector('manifest item[id="ncx"][media-type="application/x-dtbncx+xml"]');
                    if (ncxItem) {
                        tocHref = ncxItem.getAttribute('href');
                    } else {
                         // Fallback: If no explicit TOC, use spine order as chapters
                         console.warn("No standard TOC found. Using spine as chapters.");
                    }
                }


                let tocContent = null;
                if (tocHref) {
                    const tocFile = zip.file(opfBaseDir + tocHref);
                    if (tocFile) {
                        tocContent = await tocFile.async('string');
                    } else {
                        console.warn(`TOC file not found at ${opfBaseDir + tocHref}`);
                    }
                }

                if (tocContent && isNavDoc) {
                    // EPUB3 Nav Document parsing
                    const navDoc = parser.parseFromString(tocContent, 'text/html'); // Nav Doc is XHTML
                    // Find the <nav epub:type="toc"> section, and then list items within it
                    const navToc = navDoc.querySelector('nav[epub\\:type="toc"], nav[type="toc"]'); // handle both epub:type and just type
                    if (navToc) {
                        const navPoints = navToc.querySelectorAll('li > a'); // Select direct links in list items
                        for (const navPoint of navPoints) {
                            const title = navPoint.textContent.trim();
                            let href = navPoint.getAttribute('href');
                            if (href) {
                                // Resolve path relative to TOC file
                                href = new URL(href, new URL(tocHref, 'zip://' + opfBaseDir)).pathname.replace('zip://', '');
                                // Clean up any fragment identifiers (e.g., #intro)
                                const cleanHref = href.split('#')[0];
                                if (!chapters.some(ch => ch.href === cleanHref)) { // Avoid duplicates if same file is referenced multiple times
                                    chapters.push({ title: title, href: cleanHref, rawParagraphs: [] });
                                }
                            }
                        }
                    }
                } else if (tocContent && !isNavDoc) {
                    // EPUB2 NCX parsing
                    const ncxDoc = parser.parseFromString(tocContent, 'application/xml');
                    // NCX uses 'ncx' namespace
                    const ncxNamespace = 'http://www.daisy.org/z3986/2005/ncx/';
                    const navPoints = ncxDoc.querySelectorAll('navPoint');
                    for (const navPoint of navPoints) {
                        const navLabel = navPoint.querySelector('navLabel text');
                        const content = navPoint.querySelector('content');
                        if (navLabel && content) {
                            const title = navLabel.textContent.trim();
                            let src = content.getAttribute('src');
                            if (src) {
                                // Resolve path relative to NCX file
                                src = new URL(src, new URL(tocHref, 'zip://' + opfBaseDir)).pathname.replace('zip://', '');
                                const cleanHref = src.split('#')[0]; // Clean up fragments
                                if (!chapters.some(ch => ch.href === cleanHref)) {
                                    chapters.push({ title: title, href: cleanHref, rawParagraphs: [] });
                                }
                            }
                        }
                    }
                }

                // Fallback: If no TOC, use spine items as chapters
                if (chapters.length === 0) {
                     const spineItems = opfDoc.querySelectorAll('spine itemref');
                     let chapterCounter = 1;
                     for (const itemRef of spineItems) {
                         const idRef = itemRef.getAttribute('idref');
                         const href = idToHrefMap.get(idRef);
                         if (href && (href.endsWith('.xhtml') || href.endsWith('.html'))) {
                             const cleanHref = href.split('#')[0];
                             // Avoid adding duplicates if spine references same file multiple times (unlikely but safe)
                             if (!chapters.some(ch => ch.href === cleanHref)) {
                                chapters.push({ title: `Chapter ${chapterCounter++}`, href: cleanHref, rawParagraphs: [] });
                             }
                         }
                     }
                }

                // Now, load and parse paragraphs for each chapter
                for (let i = 0; i < chapters.length; i++) {
                    const chapter = chapters[i];
                    const htmlFullZipPath = opfBaseDir + chapter.href; // Path inside the ZIP
                    const htmlFile = zip.file(htmlFullZipPath);

                    if (htmlFile) {
                        const htmlContent = await htmlFile.async('string');
                        const htmlDoc = parser.parseFromString(htmlContent, 'text/html');
                        const pElements = htmlDoc.querySelectorAll('p');
                        const chapterParagraphs = [];
                        pElements.forEach(p => {
                            const text = p.textContent.trim();
                            if (text) {
                                chapterParagraphs.push(`<p>${text}</p>`);
                            }
                        });
                        chapter.rawParagraphs = chapterParagraphs; // Store paragraphs directly in chapter object
                    } else {
                        console.warn(`Warning: Chapter HTML file not found in ZIP: ${htmlFullZipPath}`);
                        chapter.rawParagraphs = []; // No paragraphs for this chapter
                    }
                }

                // Filter out chapters with no content (e.g., if a TOC entry pointed to an image or empty file)
                chapters = chapters.filter(ch => ch.rawParagraphs && ch.rawParagraphs.length > 0);


                if (chapters.length > 0) {
                    // Store ALL chapter data (including paragraphs) for later recall
                    localStorage.setItem(LAST_PROCESSED_PARAGRAPHS_KEY, JSON.stringify(chapters));

                    loadReadingSpot(); // Load saved spot (chapter and paragraph index)
                    displayCurrentParagraph(); // Display current paragraph (will also update word count etc.)
                    displayChapterButtons(); // Create and show chapter buttons
                    highlightActiveChapterButton(); // Highlight the currently active chapter
                    enableControls();
                    startButton.disabled = false;
                    pauseResumeButton.disabled = true;
                } else {
                    outputDiv.textContent = "No readable chapters or paragraphs found in this EPUB.";
                    disableControls();
                    localStorage.removeItem(LAST_PROCESSED_PARAGRAPHS_KEY);
                    localStorage.removeItem(CURRENT_READER_SPOT_KEY);
                    localStorage.removeItem(CURRENT_CHAPTER_SPOT_KEY);
                }

            } catch (error) {
                outputDiv.textContent = `Error: ${error.message}`;
                console.error(error);
                allParagraphs = [];
                chapters = [];
                disableControls();
                localStorage.removeItem(LAST_SELECTED_FILE_KEY);
                localStorage.removeItem(LAST_PROCESSED_PARAGRAPHS_KEY);
                localStorage.removeItem(CURRENT_READER_SPOT_KEY);
                localStorage.removeItem(CURRENT_CHAPTER_SPOT_KEY);
            }
        }

        // Function to run on page load
        function loadPreviousSelection() {
            loadTotalWordsRead();

            const lastSelectedFileData = localStorage.getItem(LAST_SELECTED_FILE_KEY);
            const lastProcessedChapters = localStorage.getItem(LAST_PROCESSED_PARAGRAPHS_KEY); // Now storing chapters

            disableControls();

            if (lastSelectedFileData && lastProcessedChapters) {
                try {
                    const fileInfo = JSON.parse(lastSelectedFileData);
                    chapters = JSON.parse(lastProcessedChapters); // Parse as chapters array

                    messageDiv.innerHTML = `
                        <p>You previously processed "<strong>${fileInfo.name}</strong>" (last processed on ${new Date(fileInfo.timestamp).toLocaleString()}).</p>
                        <p>If you wish to re-process, select the file again. Otherwise, you can continue reading.</p>
                    `;
                    messageDiv.style.display = 'block';

                    if (chapters.length > 0) {
                        loadReadingSpot(); // Load saved chapter AND paragraph spot
                        displayCurrentParagraph();
                        displayChapterButtons();
                        highlightActiveChapterButton();
                        enableControls();
                        pauseResumeButton.disabled = true;
                    } else {
                        outputDiv.textContent = 'No previously processed content found for this book (or it was empty).';
                        localStorage.removeItem(LAST_PROCESSED_PARAGRAPHS_KEY);
                        localStorage.removeItem(CURRENT_READER_SPOT_KEY);
                        localStorage.removeItem(CURRENT_CHAPTER_SPOT_KEY);
                    }

                } catch (e) {
                    console.error("Error parsing stored data:", e);
                    outputDiv.textContent = 'Could not load previous data. Please select a file.';
                    localStorage.removeItem(LAST_SELECTED_FILE_KEY);
                    localStorage.removeItem(LAST_PROCESSED_PARAGRAPHS_KEY);
                    localStorage.removeItem(CURRENT_READER_SPOT_KEY);
                    localStorage.removeItem(CURRENT_CHAPTER_SPOT_KEY);
                }
            } else {
                outputDiv.textContent = 'Select an EPUB file to begin.';
            }
            updateStatus();
        }

        // Call this function when the page loads
        window.addEventListener('load', loadPreviousSelection);
        // Save current spot if user closes tab/navigates away
        window.addEventListener('beforeunload', saveReadingSpot);
    </script>
</body>
</html>